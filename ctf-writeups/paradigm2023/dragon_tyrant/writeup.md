# Dragon Tyrant

The goal of this challenge is to defeat the dragon. To win, the following two conditions are required.

1. Make Fighterâ€™s strength and constitution to `type(uint40).max`
2. In `NFT._resolveFight()`, the Fighter defends when the dragon attacks, and attacks when the dragon defends (because the dragon's health is 60 and our fighter's health is 1)

For both conditions 1 and 2, the radom value generated by the `round` and the `seed` submitted by the radomnessOperator are important. When the randomnessOperator calls `resolveRandomness()`, new Fighters are minted and the pending fight proceeds. First, in order to satisfy condition 1, when the NFT is minted, we can check whether the `type(uint40).max` value is achievable when the NFT's stat is equipped with an item in the `onERC721Received()` function of the receiver contract. If achievable, the receiver contract will purchase `Broadsword` and `Wooden Shield` from the ItemShop and equip them to the Fighter.

To achieve condition 2, the attackerContract must know in advance what actions the dragon will perform. Whether the dragon attacks or defends is determined via `uint256 attackeeInputs = uint256(_generateRandomness(round));`. In order to perform an action opposite to the dragon's action, the `attackerContrac.getInput()` function must return  `~bits(attackeeInputs)`. Here, `round` used when calculating `attackeeInputs` is the next round after the round in which the last Fighter was minted. Therefore, we checked whether the random value of `round+1` can be obtained through the previous round when the seed is the same.

In fact, we can calculate the next round's `randomness.generate(seed, round)` value. The random generator looks like this:

```
G = (1, 2) # generator of BN128
P = 0x123456789 * G
Q = keccak256(0x123456789) * G
for (uint i = 0; i < rounds; i++) {
	seed = (seed * P).x
}
rand = (seed * Q).x
```

We can calculate the next round's `rand` (=`rand'`) like:

```
The division (/) here is division over modulo of BN128 curve order. (=pow(x, -1, order))

R = (x, y) point for x=rand (y can be calculated from x)

R
= seed * Q
= seed * (keccak256(0x123456789) / 0x123456789) * P

Let's call
d = (keccak256(0x123456789) / 0x123456789)

Then
seed = ((d^-1)P).x

Then we know seed, so we can get
rand'
= (seed * P).x
```

Because there was a vulnerability in which `_generateRandomness(round+1)` could be determined based on the `_generateRandomness(round)` value, the attackerContract, which is the receiver contract when a new Fighter is created, can calculate the dragon's behavior in advance. So by returning `~generateRandomness(fight round)` from getInput(), we can defend when the dragon attacks, and attack when the dragon defends. In this case, Fighter wins and the dragon NFT is burned.